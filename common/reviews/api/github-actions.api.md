## API Report File for "@kcws/github-actions"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="jest" />
/// <reference types="node" />

import { AnnotationProperties } from '@actions/core';
import { ExecOptions } from '@actions/exec';
import { Globber } from '@actions/glob';
import { CopyOptions as IOCopyOptions } from '@actions/io';
import { GlobOptions as IOGlobOptions } from '@actions/glob';
import { MoveOptions as IOMoveOptions } from '@actions/io';

// @public
export class App<C extends BaseContext, I> implements BaseApp<C, I> {
    // Warning: (ae-forgotten-export) The symbol "AppHooks" needs to be exported by the entry point index.d.ts
    constructor(context: C, dataBuilder: RunnerDataBuilder<C, I>, hooks?: AppHooks<C, I>);
    // (undocumented)
    readonly context: C;
    run(runner: Runner<C, I>, input?: Partial<I> | undefined): Promise<void>;
}

// Warning: (ae-forgotten-export) The symbol "Builder" needs to be exported by the entry point index.d.ts
//
// @public
export class AppBuilder<C extends BaseContext = BaseContext, I = NonNullable<unknown>, RAW_C extends BaseContext = BaseContext, RAW_I = NonNullable<unknown>> implements Builder<BaseApp<ContextMerged<C, RAW_C>, I & RAW_I>> {
    build(): App<ContextMerged<C, RAW_C>, I & RAW_I>;
    static readonly defaultContext: BaseContext<{}>;
    static readonly defaultData: RunnerData<NonNullable<unknown>>;
    static empty(): AppBuilder<BaseContext<{}>, {}, BaseContext<{}>, {}>;
    // Warning: (ae-forgotten-export) The symbol "DataFromBuilder" needs to be exported by the entry point index.d.ts
    static fromBuilders<CB extends ContextBuilder, NI>(contextBuilder: CB, dataBuilder: RunnerDataBuilder<DataFromBuilder<CB>, NI>): AppBuilder<DataFromBuilder<CB>, NI, BaseContext<{}>, {}>;
    static fromContextBuilder<CB extends ContextBuilder>(contextBuilder: CB): AppBuilder<DataFromBuilder<CB>, {}, BaseContext<{}>, {}>;
    static fromDataBuilder<NI>(dataBuilder: RunnerDataBuilder<BaseContext, NI>): AppBuilder<BaseContext<{}>, NI, BaseContext<{}>, {}>;
    setContext<NC extends BaseContext>(context: NC): AppBuilder<C, I, NC, RAW_I>;
    setContextBuilder<NC extends BaseContext, NI>(contextBuilder: ContextBuilderFromContext<NC>, dataBuilder: RunnerDataBuilder<NC, NI>): AppBuilder<NC, NI, RAW_C, RAW_I>;
    setData<NI>(data: RunnerData<NI>): AppBuilder<C, I, RAW_C, NI>;
    setDataBuilder<NI>(dataBuilder: RunnerDataBuilder<C, NI>): AppBuilder<C, NI, RAW_C, RAW_I>;
    setHook<K extends keyof AppHooks<ContextMerged<C, RAW_C>, I & RAW_I>>(key: K, hook: AppHooks<ContextMerged<C, RAW_C>, I & RAW_I>[K]): this;
    setHooks(hooks: AppHooks<ContextMerged<C, RAW_C>, I & RAW_I>): this;
}

// @public
export type AppBuilderContext<B extends Builder<unknown>> = AppContext<DataFromBuilder<B>>;

// @public
export type AppBuilderData<B extends Builder<unknown>> = AppData<DataFromBuilder<B>>;

// @public
export type AppBuilderRunner<B extends Builder<unknown>> = AppRunner<DataFromBuilder<B>>;

// @public
export type AppContext<APP> = APP extends BaseApp<infer C, unknown> ? C : never;

// @public
export type AppData<APP> = APP extends BaseApp<BaseContext, infer I> ? I : never;

// @public
export type AppRunner<APP> = APP extends BaseApp<infer C, infer I> ? Runner<C, I> : never;

// @public
export interface BaseApp<C extends BaseContext, I> {
    // (undocumented)
    readonly context: C;
    run(runner: Runner<C, I>, input?: Partial<I>): Promise<void>;
}

// @public
export interface BaseContext<PLUGINS extends Plugins<BaseContext, string[]> = NonNullable<unknown>> {
    // (undocumented)
    has(name: string): boolean;
    // (undocumented)
    merge<PS extends Plugins>(context: BaseContext<PS>): BaseContext<PLUGINS & PS>;
    readonly name: string;
    readonly plugins: PLUGINS;
    // (undocumented)
    use<K extends keyof PLUGINS>(name: K): PLUGINS[K];
    readonly version: string;
}

// @public
export interface BaseConverter<I, O> {
    // Warning: (ae-incompatible-release-tags) The symbol "convert" is marked as @public, but its signature references "Convert" which is marked as @internal
    //
    // (undocumented)
    convert: Convert<I, O>;
    // (undocumented)
    readonly inputType: string;
    // (undocumented)
    readonly targetType: string;
}

// @public
export class CacheContextPlugin implements ICacheContextPlugin {
    // (undocumented)
    readonly dependencies: readonly ["log"];
    getRestoreKeys(option: CacheKeyOption): string[];
    getSaveKey(option: CacheKeyOption): string;
    hasFeature(): boolean;
    // (undocumented)
    init(context: ICacheContext): void;
    // (undocumented)
    readonly name: "cache";
    // (undocumented)
    restore(option: CacheKeyOption, ...paths: string[]): Promise<string | undefined>;
    // (undocumented)
    save(option: CacheKeyOption, ...paths: string[]): Promise<void>;
}

// @public
export interface CacheKeyOption {
    actionName?: boolean;
    // (undocumented)
    custom?: string[] | null;
    // (undocumented)
    system?: boolean | SystemCacheKeyOption;
}

// @public
export interface CapturedResult {
    // (undocumented)
    code: number;
    // (undocumented)
    stderr?: Buffer;
    // (undocumented)
    stdout?: Buffer;
}

// @public
export class ContextBuilder<PLUGINS extends Plugins = NonNullable<unknown>> implements Builder<BaseContext<PLUGINS>> {
    // (undocumented)
    addPlugin<P extends ContextPlugin<string, BaseContext<PLUGINS>, (keyof PLUGINS extends string ? keyof PLUGINS : never)[]>>(plugin: P): ContextBuilder<PLUGINS & Record<P["name"], P>>;
    // (undocumented)
    build(): BaseContext<PLUGINS>;
    // (undocumented)
    static readonly defaultName = "";
    // (undocumented)
    static readonly defaultVersion = "v0.0.0-dev";
    static empty(): ContextBuilder<{}>;
    static fromContext<CTX extends BaseContext = BaseContext>(context: CTX): ContextBuilder<CTX["plugins"]>;
    static fromInput(name?: string, version?: string): ContextBuilder<{}>;
    static fromPackageJson(basedir: string, filename?: string): ContextBuilder<{}>;
    // (undocumented)
    setName(name: string): this;
    // (undocumented)
    setPlugins<PS extends Plugins = NonNullable<unknown>>(plugins: PS): ContextBuilder<PS>;
    // (undocumented)
    setVersion(version: string): this;
}

// @public
export type ContextBuilderFromContext<CONTEXT extends BaseContext> = ContextBuilder<CONTEXT["plugins"]>;

// @public
export type ContextMerged<CONTEXT1 extends BaseContext, CONTEXT2 extends BaseContext> = BaseContext<CONTEXT1["plugins"] & CONTEXT2["plugins"]>;

// Warning: (ae-forgotten-export) The symbol "ToDependencies" needs to be exported by the entry point index.d.ts
//
// @public
export interface ContextPlugin<NAME extends string, CTX extends BaseContext = BaseContext, DEPS extends unknown[] = ToDependencies<CTX>> {
    dependencies: Readonly<DEPS>;
    init(context: CTX): void;
    name: Readonly<NAME>;
}

// @public
export class ContextPluginNotFound<K> extends Error {
    constructor(name: K);
}

// Warning: (ae-internal-missing-underscore) The name "Convert" should be prefixed with an underscore because the declaration is marked as @internal
//
// @internal
export type Convert<Input, Output> = (input: Input) => Output;

// @public
export const convert: <Output, Input>(data: Input, converter: BaseConverter<Input, Output>) => Output;

// Warning: (ae-forgotten-export) The symbol "Convert_2" needs to be exported by the entry point index.d.ts
//
// @public
export const convertToBool: Convert_2;

// Warning: (ae-forgotten-export) The symbol "Convert_3" needs to be exported by the entry point index.d.ts
//
// @public
export const convertToFloat: Convert_3;

// Warning: (ae-forgotten-export) The symbol "Convert_4" needs to be exported by the entry point index.d.ts
//
// @public
export const convertToInt: Convert_4;

// Warning: (ae-forgotten-export) The symbol "Convert_5" needs to be exported by the entry point index.d.ts
//
// @public
export const convertToString: Convert_5;

// @public
export class DefaultContext<PLUGINS extends Plugins<DefaultContext, string[]> = NonNullable<unknown>> implements BaseContext<PLUGINS> {
    constructor(name: string, version: string, plugins: PLUGINS);
    has(name: string): boolean;
    init(force?: boolean): void;
    merge<PS extends Plugins<BaseContext, string[]>>(context: BaseContext<PS>): DefaultContext<PLUGINS & PS>;
    readonly name: string;
    readonly plugins: PLUGINS;
    use<K extends keyof PLUGINS>(name: K): PLUGINS[K];
    readonly version: string;
}

// @public
export class EnvContextPlugin implements IEnvContextPlugin {
    constructor();
    // (undocumented)
    readonly dependencies: readonly [];
    getCombination(keys: string[], defaults?: string, environments?: Envvars): string | undefined;
    // (undocumented)
    init(): void;
    lookup(keys: string[], environments?: Envvars): string | undefined;
    // (undocumented)
    readonly name: "env";
    setEnvironments(environments: Envvars): this;
}

// @public
export type Envvars = Record<string, string | undefined | null>;

// @public
export class ExecContextPlugin implements IExecContextPlugin {
    constructor();
    captureRerun(cmd: string, ...args: string[]): Promise<CapturedResult>;
    captureRun(cmd: string, ...args: string[]): Promise<CapturedResult>;
    // (undocumented)
    readonly dependencies: readonly ["log", "input"];
    // (undocumented)
    init(context: IExecContext): void;
    // (undocumented)
    readonly name: "exec";
    rerun(cmd: string, ...args: string[]): Promise<number>;
    run(cmd: string, ...args: string[]): Promise<number>;
    withOptions(options: ExecOptions): this;
}

// @public
export class FileNotFound extends Error {
    constructor(basedir: string, filename: string);
}

// @public
export type GroupRunner<C extends BaseContext, R> = (ctx: C) => R | Promise<R>;

// @public
export type ICacheContext = BaseContext<ToPluginsObject<[LogContextPlugin]>>;

// @public
export type ICacheContextPlugin = ContextPlugin<"cache", ICacheContext>;

// @public
export type IEnvContext = BaseContext;

// @public
export type IEnvContextPlugin = ContextPlugin<"env", IEnvContext>;

// @public
export type IExecContext = BaseContext<ToPluginsObject<[LogContextPlugin, InputContextPlugin]>>;

// @public
export type IExecContextPlugin = ContextPlugin<"exec", IExecContext>;

// @public
export type IInputContext = BaseContext<ToPluginsObject<[EnvContextPlugin]>>;

// @public
export type IInputContextPlugin = ContextPlugin<"input", IInputContext>;

// @public
export type IIOContext = BaseContext;

// @public
export type IIOContextPlugin = ContextPlugin<"io", IIOContext>;

// @public
export type ILogContext = BaseContext;

// @public
export type ILogContextPlugin = ContextPlugin<"log", ILogContext>;

// Warning: (ae-forgotten-export) The symbol "DataBuilder" needs to be exported by the entry point index.d.ts
//
// @public
export type InputBuilder<C extends BaseContext, I> = DataBuilder<C, I>;

// @public
export class InputContextPlugin implements IInputContextPlugin {
    // (undocumented)
    readonly dependencies: readonly ["env"];
    // (undocumented)
    init(context: IInputContext): void;
    // (undocumented)
    readonly name: "input";
    // (undocumented)
    optional<Output>(name: string, converter: BaseConverter<string, Output>): Output | undefined;
    // (undocumented)
    optionalString(name: string): string | undefined;
    // (undocumented)
    required<Output>(name: string, converter: BaseConverter<string, Output>): Output;
    // (undocumented)
    requiredString(name: string): string;
}

// @public
export class IOContextPlugin implements IIOContextPlugin {
    copy(source: string, dest: string, options?: IOCopyOptions): Promise<void>;
    createGlob(pattern: string, options?: IOGlobOptions): Promise<Globber>;
    // (undocumented)
    readonly dependencies: readonly [];
    hash(pattern: string, cwd?: string): Promise<string>;
    // (undocumented)
    init(): void;
    move(source: string, dest: string, options?: IOMoveOptions): Promise<void>;
    // (undocumented)
    readonly name: "io";
}

export { IOCopyOptions }

export { IOGlobOptions }

export { IOMoveOptions }

// @public
export type IOutputContext = BaseContext;

// @public
export type IOutputContextPlugin = ContextPlugin<"output", IOutputContext>;

// @public
export type ISystemContext = BaseContext;

// @public
export type ISystemContextPlugin = ContextPlugin<"system", ISystemContext>;

// @public
export class LogContextPlugin implements ILogContextPlugin {
    constructor(verbose?: boolean);
    debug(format: string, ...data: LogData): void;
    // (undocumented)
    static readonly defaultUnknownInfo = "Action info missing";
    // (undocumented)
    static readonly defaultUnknownName = "unknown-app";
    // (undocumented)
    static readonly defaultUnknownVersion = "unknown-version";
    // (undocumented)
    readonly dependencies: readonly [];
    error(data: string | Error, properties?: AnnotationProperties): void;
    format(format: string, ...data: LogData): string;
    group<OUT>(name: string, runner: GroupRunner<ILogContext, OUT>): Promise<OUT>;
    info(format: string, ...data: LogData): void;
    // (undocumented)
    init(context: ILogContext): void;
    // (undocumented)
    readonly name: "log";
    notice(data: string | Error, properties?: AnnotationProperties): void;
    throw(error: Error): void;
    warn(data: string | Error, properties?: AnnotationProperties): void;
}

// @public
export type LogData = PrimitiveType[] | (Record<string, PrimitiveType> | undefined)[];

// @public
export class MethodNotImplemented extends Error {
    constructor(method: string);
}

// @public
export const mockEnvironment: <Environment extends NodeJS.ProcessEnv, T>(environment: Environment, callback: (environment_: Environment) => T) => T;

// Warning: (ae-forgotten-export) The symbol "MockContextPlugin" needs to be exported by the entry point index.d.ts
//
// @public
export const mockPlugin: <N extends string, DEPS extends string[] = never[]>(name: N, dependencies?: DEPS | undefined) => MockContextPlugin<N, DEPS>;

// @public
export const mockRunner: <APP extends BaseApp<BaseContext<{}>, {}>>(_app: APP) => jest.Mock<void | Promise<void>, [RunnerData<AppData<APP>>, AppContext<APP>], any>;

// @public
export const mockRunnerData: <I>(input: I) => RunnerData<I>;

// @public
export const mockRunnerDataBuilder: <I, CB extends ContextBuilder<{}> = ContextBuilder<{}>>(input: I, _builder?: CB | undefined) => RunnerDataBuilder<DataFromBuilder<CB>, I>;

// @public
export class OutputContextPlugin implements IOutputContextPlugin {
    // (undocumented)
    readonly dependencies: readonly [];
    // (undocumented)
    init(): void;
    markAsSecret(value: string): void;
    // (undocumented)
    readonly name: "output";
    setOutput<V>(name: string, value: V): void;
}

// @public
export type Plugins<CTX extends BaseContext = BaseContext, DEPS extends string[] = []> = Record<string, ContextPlugin<string, CTX, DEPS>>;

// @public
export type PrimitiveType = string | number | boolean | undefined;

// @public
export type Runner<C extends BaseContext, I> = (data: RunnerData<I>, context: C) => void | Promise<void>;

// @public
export interface RunnerData<I> {
    input: I;
}

// @public
export type RunnerDataBuilder<C extends BaseContext, I> = DataBuilder<C, RunnerData<I>>;

// @public
export class SimpleContext implements BaseContext {
    constructor(name?: string, version?: string);
    // (undocumented)
    has(_: string): boolean;
    // (undocumented)
    merge<PS extends Plugins>(_: BaseContext<PS>): BaseContext<(typeof SimpleContext)["plugins"] & PS>;
    // (undocumented)
    readonly name: string;
    // (undocumented)
    readonly plugins: {};
    // (undocumented)
    use(_: string): never;
    // (undocumented)
    readonly version: string;
}

// @public
export interface SystemCacheKeyOption {
    // (undocumented)
    arch?: boolean;
    // (undocumented)
    platform?: boolean;
}

// @public
export class SystemContextPlugin implements ISystemContextPlugin {
    addPath(additionalPath: string): void;
    addPaths(...additionalPaths: string[]): void;
    // (undocumented)
    readonly dependencies: readonly [];
    // (undocumented)
    init(): void;
    // (undocumented)
    readonly name: "system";
    setEnvVar<V>(name: string, value: V): void;
    which(tool: string, check?: boolean): Promise<string>;
}

// Warning: (ae-forgotten-export) The symbol "Converter" needs to be exported by the entry point index.d.ts
//
// @public
export const toBool: Converter;

// Warning: (ae-forgotten-export) The symbol "Converter_2" needs to be exported by the entry point index.d.ts
//
// @public
export const toFloat: Converter_2;

// Warning: (ae-forgotten-export) The symbol "Converter_3" needs to be exported by the entry point index.d.ts
//
// @public
export const toInt: Converter_3;

// Warning: (ae-forgotten-export) The symbol "ToPluginObject" needs to be exported by the entry point index.d.ts
//
// @public
export type ToPluginsObject<T> = T extends [infer FIRST, ...infer TAIL] ? ToPluginObject<FIRST> & (TAIL extends ContextPlugin<string, BaseContext<Plugins<BaseContext, string[]>>, string[]>[] ? ToPluginsObject<TAIL> : unknown) : unknown;

// Warning: (ae-forgotten-export) The symbol "Converter_4" needs to be exported by the entry point index.d.ts
//
// @public
export const toString: Converter_4;

// (No @packageDocumentation comment for this package)

```
